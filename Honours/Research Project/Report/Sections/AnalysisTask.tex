Writing an analysis task in O2 is structured quite strictly, due to it needing to be run by O2. We will outline the steps needed to go from reconstructed data to histograms of, in our case, kinematic variables. It must be noted that learning how to do this, and how to deal with the idiosyncrasies of the O2 software, were what took up the majority of the time spent on this project. It is written to do one thing very very well, but unfortunately that comes with the side-effect of it being extremely picky about the conditions in which the software will actually work. 

\subsection{AOD Structure}\label{sec:AODStructure}
The data that we use in our analysis comes in the form of Analysis Object Data. These are in the form of ROOT files, which are based on a tree structure. In the tree are a number of tables corresponding to reconstructed tracks and collisions, among a few others. We call these entries or rows. For each of these tables, there are a number of reconstructed variables associated with each entry, such as their $\pt$, $\eta$, or $\varphi$, which we can access. There are 4 types of variables:
\begin{itemize}
    \item Static variables are saved to disk during the reconstruction process and are available at any time. $\varphi$ is a static variable.
    \item Dynamic variables are calculated on demand, using static variables as input. $\eta$ is a dynamic variable, calculated from $\theta$. 
    \item Index variables point from one table to another, such as from a track to its associated collision.
    \item Expression variables no clue
\end{itemize}

All variables associated with a track, for example, could be included in a single table. However, since we often only need a few of the variables, the tables are split up into sections that contain variables often used together. If needed, these tables can be joined together when doing analysis, using \lstinline[language=C++]{o2::soa::Join<Table1, Table2>}. Importantly, only tables which correspond row-to-row and have the same number of rows can be joined in this way.

\subsection{Analysis Task Structure}\label{sec:TaskStructure}
Analysis tasks are written in \Cpp and need to be structured in a specific way for O2 to use them properly. Each task is written as a \lstinline[language=C++]{struct} object which is then called at the end of the task. Below is an outline of what is needed for a task.

\begin{lstlisting}
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"

struct MyTask {
    // Define things here, such as histogram registries, filters for data, or new tables

    void init{o2::framework::InitContext&} {
        // Here we initialise histograms and other things used in the analysis
    };

    void process(aod::Collisions const& collisions, aod::Tracks const& tracks) {
        // Here we can do any processing that we need, calculating things etc, and then fill the histograms we defined earlier
    };
};

// This is what O2 looks at to run the task
WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTask>(cfgc),
  };
}

\end{lstlisting}

With the task written, it then needs to be compiled and added to O2 so that it can be run. To do this, we can either add our task to an existing folder or create our own. We chose to create our own as it was easier to manage. 

\dirtree{%
  .1 alice.
  .2 alidist.
  .2 O2.
  .2 O2Physics.
  .3 Functional Things.
  .3 ....
  .3 myTasks.
  .4 CMakeLists.txt.
  .4 Tasks.
  .5 CMakeLists.txt.
  .5 analysisTask.cxx.
  .5 ....
  .3 Other Working Groups.
  .3 ....
  .3 CMakeLists.txt.
}

Here \texttt{alidist} is the git repository that handles the versioning of O2 and O2Physics. O2 is what handles the backend of the analysis framework, compiling the tasks written in O2Physics. The \texttt{CMakeLists.txt} files are needed at every level of the O2Physics structure to tell O2 what to compile and which commands to use to refer to things. 

\subsection{Compiling O2 & Running a Task}\label{sec:CompileRun}
O2 is built on your system using \texttt{aliBuild}~\cite{aliBuild_install}