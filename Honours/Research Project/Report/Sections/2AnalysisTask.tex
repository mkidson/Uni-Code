One of the main goals of O2 is to take away as much responsibility from the user as possible when it comes to managing memory, writing efficient code, and disk space usage. To this end, writing an analysis task in O2 is structured quite strictly. This section will outline the information needed when trying to analyse reconstructed data to produce, in our case, histograms of kinematic variables. 

It must be noted that learning how to do this, and how to deal with the idiosyncrasies of the O2 software, is what took up the majority of the time spent on this project. O2 is written to do one thing very, very well, but unfortunately that comes with the side-effect of it being extremely picky about the conditions in which the software will actually work. Lastly, a distinction needs to be made between O2 and O2Physics. O2 generally refers to the entire analysis framework, including both the online and offline parts. This encompasses O2Physics, which is used only for offline analysis. Despite this, in terms of the structure of the software, O2 and O2Physics are separate things but O2Physics sometimes depends on O2. For this reason it can become ambiguous when discussing O2 and O2Physics but we will try our best to keep them distinct. 

\subsection{AOD Structure}\label{sec:AODStructure}
The data that we use in our analysis comes in the form of Analysis Object Data. These get produced asynchronously and come in the form of ROOT files containing ``Dataframes''. These are organised in a tree structure where each tree contains a number of tables, for example a table containing collisions and a table containing tracks. The tables have columns which hold variables corresponding to each entry, or row, in the table. There are 4 types of column:

\begin{itemize}
    \item Static columns are saved to disk during the reconstruction process and are available at any time. The $z$-position of a collision vertex, for example, is a static variable.
    \item Dynamic columns are defined as functions with inputs from static variables (or variables input by the user). They will produce a result on demand in order to save memory and disk space. Momentum in the $x$-direction is a dynamic variable.
    \item Index columns point from one table to another, such as from a track to its associated collision. They can also refer to their own table, such as for a simulated particle to refer to its mother or daughter particle after decay.
    \item Expression columns are similar to dynamic columns in that they get calculated on demand, but they get evaluated on all entries in a table upon requesting it and produce a column that can then be accessed as if it were a static column. Importantly, dynamic columns cannot be used as inputs to expression columns.
\end{itemize}

\subsection{Analysis Task Structure}\label{sec:TaskStructure}
Analysis tasks are written in C\OldTexttt{++} and need to be structured in a specific way so that O2Physics can use them properly. Each task is written as a \texttt{struct} object which is then called at the end of the task. Below is an outline of what is needed for a task.

\begin{minted}{c++}
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"

using namespace o2;

struct MyTask {
  // Define things here, such as histogram registries, filters for data, or new tables

  void init(framework::InitContext&) {
    // Here we initialise histograms and other things used in the analysis
  };
  // The arguments of the process function are where we subscribe to specific tables in the AOD that we're analysing. 
  void process(aod::Collision const& collision, aod::Tracks const& tracks) {
    // Here we can do any processing that we need, calculating things etc, and then fill the histograms we defined earlier
  };
};

// This is what O2 looks at to run the task
WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTask>(cfgc),
  };
}
\end{minted}

\subsection{Table Features}
All variables associated with a track, for example, could be included in a single table. However, since we often only need a few of the variables, the tables are split up into sections that contain variables often used together. If needed, these tables can be joined together when doing analysis using \texttt{o2::soa::Join<Table1, Table2>}. Importantly, only tables which correspond row-to-row and have the same number of rows can be joined in this way.

We might also want to only access entries in a table that pass some filter, say having $|\eta| < 0.8$. We can do this by putting \texttt{Filter f = nabs(aod::track::eta) < 0.8;} somewhere before the \texttt{process} function and then instead of subscribing to \texttt{aod::Tracks} as we have done, we can put \texttt{soa::Filtered<aod::Tracks> const\& filteredTracks} in the \texttt{process} function call. Multiple filters can be defined and only compatible tables will be filtered. Once a table has been filtered, the unfiltered version cannot be accessed. 

Similar to filters are partitions, which we define like \texttt{Partition<aod::Tracks> leftEta = aod::track::eta < 0;}. This will create a separate table that we can subscribe to which will only contain tracks with the specified $\eta$ value. This is different to a filter as the original table can also be accessed at any time. 

Some tables have pre-defined iterators which can be used to more efficiently loop through all entries in the table. \texttt{Collisions}, for example, has an iterator called \texttt{Collision} that we subscribed to in the code example above. When a table has an index column relating to \texttt{Collisions}, as \texttt{Tracks} is, O2 will automatically group the entries in \texttt{Tracks} by associated collision. 

\subsection{Histogram Registry}
Histograms are the eventual desired output of an analysis task and O2 has a class designed specifically to make creating and filling histograms easier. Before the \texttt{init} function we can define our histogram registry and then in the \texttt{init} function we can define the histograms we want and add them to the registry. We can then fill the histograms in the \texttt{process} function.

\begin{minted}{c++}
HistogramRegistry myRegistry{ // This name and the name in the next line need to be the same
  "myRegistry",
  {},   // Histograms could be defined here but we will do it in init()
  OutputObjHandlingPolicy::AnalysisObject,  // Tells the task which format to output in
  true,   // Sorts the output histograms alphabetically
  false   // Won't create a subdirectory for this registry. Set to true if more than one registry is being used
};

void init(o2::framework::InitContext&) {
  AxisSpec etaAxis = {nBins, binMin, binMax, title} // title is what gets printed on the axis

  myRegistry.add("myHist", "myHist", kTH1F, {etaAxis})  // Initialises the histogram. First argument is the name of the histogram, to use internally, and second gets printed as the title
};

void process(aod::Tracks const& tracks) {
  for (auto& track : tracks) {
    registry.fill(HIST("myHist"), track.eta());   // Fills the histogram with eta from all tracks
  };
}
\end{minted}

\subsection{Folder Structure}\label{sec:FolderStructure}
With the task written, it then needs to be compiled and added to O2Physics so that it can be run. O2Physics has a number of analysis tasks written by people at ALICE which get compiled automatically. These are sorted into physics working groups such as Heavy Flavour (PWGHF) and Jets (PWGJE). If we want to add our own task to O2Physics, we need to create our own folder with the same structure as the working groups. Below shows the structure of the file system.

% \newpage
\dirtree{%
  .1 alice.
  .2 alidist.
  .2 O2.
  .2 O2Physics.
  .3 Functional Things.
  .3 ....
  .3 myTasks.
  .4 CMakeLists.txt.
  .4 myTask1.cxx.
  .4 Tasks.
  .5 CMakeLists.txt.
  .5 myTask2.cxx.
  .5 ....
  .3 Other Working Groups.
  .3 ....
  .3 CMakeLists.txt.
  .2 sw.
}
Here \texttt{alidist} is the git repository that handles the versioning of O2 and O2Physics. O2 is what handles the backend of the analysis framework, compiling the tasks written in O2Physics. The \texttt{CMakeLists.txt} files are needed at every level of the O2Physics structure to tell O2 what to compile and which commands to use to refer to things. 

See below an example of what the \texttt{CMakeLists.txt} file in the \texttt{myTasks} folder would look like.

\begin{minted}{text}
add_subdirectory(Tasks)                 # Ensures O2 can see the Tasks folder
o2physics_add_dpl_workflow(my-task1     # The command assigned to the task. Note only lowercase letters, hyphens, and numbers are allowed
                  SOURCES myTask1.cxx   # The source file for the task
                  PUBLIC_LINK_LIBRARIES O2::Framework
                  COMPONENT_NAME Analysis)
\end{minted}

\subsection{Compiling O2Physics}\label{sec:CompileO2Physics}
O2 and O2Physics are built using \texttt{aliBuild}~\cite{aliBuild_install}. They prefer to be built on UNIX systems and require at least 8 GB of RAM, preferably more. We used both O2 and O2Physics as we wanted to create and run analysis tasks. 

Once they are built (those four words are doing some \textit{very} heavy lifting) we can enter the O2Physics environment with \texttt{alienv enter O2Physics} and this will place us in a new terminal shell. The magic of the software is that it compiles all the analysis tasks in O2Physics, as well as tools for simulation and the like, such that everything can be done by running commands in that shell. Before running our own tasks, however, we need to tell O2 to build our tasks into O2Physics. To do this we use \texttt{ninja}.

If we have our tasks written and files structured as shown in \cref{sec:TaskStructure}, we can enter an O2Physics environment and load ninja alongside using \texttt{alienv enter O2Physics ninja/latest}. In the shell we can then navigate to the build of O2Physics, which should be in \texttt{alice/sw/BUILD\-/O2Physics-latest/O2Physics} and run \texttt{ninja install myTasks/all} which will rebuild only those parts of O2. 

Ninja is the quick and dirty way of doing things so every now and then it's a good idea to rebuild O2 and O2Physics entirely, pulling the latest release. We can do this while also making sure our own tasks don't get overwritten using the following steps. We first need to make sure that git knows our files are there with \texttt{git add path/to/files} and then committing with \texttt{git commit -m "commit message"}. With that done, we can systematically update \texttt{alidist}, \texttt{O2}, and \texttt{O2Physics} by navigating to each and running \texttt{git pull --rebase}. Finally we can rebuild by navigating to \texttt{alice} and running \texttt{aliBuild build O2Physics --defaults o2 --debug}. This will take a few hours to complete (if it's even successful) and then will be able to be used again.

\subsection{Running a Task with O2}\label{sec:RunO2}
Once we have our tasks created and built in O2Physics, we can then run them. For our purposes, the only commands we need to know are how to run a task and the options that come along with that. All analysis tasks in O2Physics get assigned a unique command that can be used to run that task. They all begin with \texttt{o2-analysis...} followed by the name assigned to it in the relevant \texttt{CMakeLists.txt} file as shown in \cref{sec:FolderStructure}. In the case of that task, we would run it with \texttt{o2-analysis-my-task1}. 

Most analysis tasks are run on \texttt{AOD.root} or \texttt{AO2D.root} files so in order to tell the task which file to use, we use the flag \texttt{--aod-file AO2D.root}. We could also supply a list of files in a text file and use \texttt{--aod-file @AO2D\_list.txt} where \texttt{AO2D\_list.txt} contains the path to the files we want to run on, one on each line. 

Often we want to run multiple tasks in succession on the same data, feeding the output of one into another. To do this, we simply use the pipe symbol \texttt{|} between the tasks: \texttt{o2-analysis-trackselection | o2-analysis-my-task1 --aod-file AO2D.root}. Here the ordering of the tasks doesn't matter as the input and output format of a task is known before it runs, so O2 does some quick thinking to arrange the workflow such that the tasks get fed the correct format of data.

The \texttt{o2-analysis-trackselection} task above is an example of a helper task. These are specifically designed to use the available data to produce tables that are needed in analysis tasks. This is done once again in the interest of saving disk space as calculating the values needed is much less resource-heavy than storing them for all time. A list of helper tasks and the tables they produce can be found at \url{https://aliceo2group.github.io/analysis-framework/docs/datamodel/helperTaskTables.html}. Note that when running a workflow with multiple tasks, if a configuration file is needed, or some other option, the flag needs to be provided before the pipe symbol for each task that gets called.

For the most part, the output of an analysis task is either a \texttt{AnalysisResults.root} file or a \texttt{QAResults.root} file, with the former being the most common. This output type is chosen when defining the histogram registry. If all goes well (which is a rare occurrence) the ROOT file produced can be opened with TBrowser and some lovely histograms should pop up. These can be saved as is or output using ROOT macros. 
