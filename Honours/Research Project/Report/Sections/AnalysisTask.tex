Writing an analysis task in O2 is structured quite strictly, due to it needing to be run by O2. We will outline the steps needed to go from reconstructed data to histograms of, in our case, kinematic variables. It must be noted that learning how to do this, and how to deal with the idiosyncrasies of the O2 software, were what took up the majority of the time spent on this project. It is written to do one thing very very well, but unfortunately that comes with the side-effect of it being extremely picky about the conditions in which the software will actually work. 

\subsection{AOD Structure}\label{sec:AODStructure}
The data that we use in our analysis comes in the form of Analysis Object Data. These are in the form of ROOT files, which are based on a tree structure. In the tree are a number of tables corresponding to reconstructed tracks and collisions, among a few others. We call these entries or rows. For each of these tables, there are a number of reconstructed variables associated with each entry, such as their $\pt$, $\eta$, or $\varphi$, which we can access. There are 4 types of variables:
\begin{itemize}
    \item Static variables are saved to disk during the reconstruction process and are available at any time. $\varphi$ is a static variable.
    \item Dynamic variables are calculated on demand, using static variables as input. $\eta$ is a dynamic variable, calculated from $\theta$. 
    \item Index variables point from one table to another, such as from a track to its associated collision.
    \item Expression variables no clue
\end{itemize}

All variables associated with a track, for example, could be included in a single table. However, since we often only need a few of the variables, the tables are split up into sections that contain variables often used together. If needed, these tables can be joined together when doing analysis, using \lstinline[language=C++]{o2::soa::Join<Table1, Table2>}. Importantly, only tables which correspond row-to-row and have the same number of rows can be joined in this way.

\subsection{Analysis Task Structure}\label{sec:TaskStructure}
Analysis tasks are written in \Cpp and need to be structured in a specific way for O2 to use them properly. Each task is written as a \lstinline[language=C++]{struct} object which is then called at the end of the task. Below is an outline of what is needed for a task.

\begin{lstlisting}[language=C++]
#include "Framework/runDataProcessing.h"
#include "Framework/AnalysisTask.h"

struct MyTask {
    // Define things here, such as histogram registries, filters for 
    // data, or new tables

    void init{o2::framework::InitContext&} {
        // Here we initialise histograms and other things used in 
        // the analysis
    };

    void process(aod::Collisions const& collisions, aod::Tracks const& tracks) {
        // Here we can do any processing that we need, calculating 
        // things etc, and then fill the histograms we defined earlier
    };
};

//This
WorkflowSpec defineDataProcessing(ConfigContext const& cfgc)
{
  return WorkflowSpec{
    adaptAnalysisTask<MyTask>(cfgc),
  };
}

\end{lstlisting}